#!/usr/bin/env perl
package main;

use strict;
use warnings qw(all -experimental::signatures);
use feature qw(say signatures);
our $VERSION = '3.0.0';

use Pacup::Parser;
use Pacup::Repology;
use Pacup::Util;

use Data::Dumper;
use Dpkg::Version qw(version_compare_relation REL_GE);
use File::Basename 'basename';
use File::chdir;
use File::Path qw(make_path rmtree);
use File::Temp 'tempdir';
use Getopt::Long;
use IPC::System::Simple qw(capture system $EXITVAL);
use LWP::UserAgent;
use Pod::Usage;
use Term::ANSIColor;
use Term::ProgressBar;

my $opt_help = 0;
my $opt_version = 0;
my $opt_show_repology = 0;
my $opt_ship = 0;
my $opt_origin_remote = 'origin';
my $opt_custom_version;
my $opt_push_force = 0;

our @collected_files;

my $PACUP_DIR;

END {
    if ( $PACUP_DIR && -d $PACUP_DIR ) {
        info 'Cleaning up';
        rmtree $PACUP_DIR;
    }
}

sub version_info {
    say 'Pacup ', colored( 'v' . $VERSION, 'bold green' );
    exit 0;
}

sub check_deps {
    my @deps = qw(dpkg git sha256sum);
    my $path = $ENV{'PATH'} || '/bin:/usr/bin';
    my @pathdirs = split /:/, $path;
    for my $dep (@deps) {
        my $found = 0;
        for my $dir (@pathdirs) {
            my $try_path = $dir . '/' . $dep;
            next unless -x $try_path;
            $found = 1;
            last;
        }
        throw 'Dependency ' . colored( $dep, 'bold' ) . ' not found'
            unless $found;
    }
}

sub fetch_source_entry ( $ua, $url, $outfile ) {
    $ua->max_redirect(0);
    $ua->show_progress(0);
    my $response = $ua->head($url);
    while ( $response->is_redirect ) {
        my $location = $response->header('Location');
        $response = $ua->head($location);
    }
    open my $fh, '>', $outfile or throw "Could not open $outfile: $!";
    if ( $response->is_success ) {
        my $final_url = $response->request->uri;
        my $file_size = $ua->head($final_url)->header('Content-Length');
        my $progress = Term::ProgressBar->new(
            {   count => $file_size,
                ETA => 'linear',
                remove => 0
            }
        );
        $progress->minor(0);
        my $received = 0;
        $response = $ua->get(
            $final_url,
            ':content_cb' => sub ( $chunk, $res, $proto ) {
                $received += length($chunk);
                $progress->update($received);
                print $fh $chunk
                    or throw "Could not write to $outfile: $!";
            }
        );
    } else {
        close $fh or throw "Could not close $outfile: $!";
        throw $response->status_line;
    }
    close $fh or throw "Could not close $outfile: $!";
}

sub calculate_hash ( $file, $hashtype ) {
    my $output = capture [ 0, 1 ], $hashtype . 'sum', ($file);
    throw "Could not calculate ${hashtype}sum of $file" unless $EXITVAL == 0;
    my ($hash) = split ' ', $output;
    return $hash;
}

sub fetch_sources ( $ua, $pkgdir, $sources, $lines ) {
    my @lines = @$lines;
    local $CWD = $pkgdir;
    for my $entry (@$sources) {
        my $url = $entry->{'url'};
        my $file = basename $url;
        info "Downloading " . colored( $file, 'bold magenta' );
        fetch_source_entry $ua, $url, $file;
        push @collected_files, "$pkgdir/$file";
        for my $hashtype (@HASHTYPES) {
            my $oldhash = $entry->{$hashtype} || next;
            subtext "Calculating ${hashtype}sum for source entry";
            my $newhash = calculate_hash $file, $hashtype;
            s/$oldhash/$newhash/ for @lines;
        }
    }
    return @lines;
}

sub main ($infile) {
    -f $infile or throw "Not a file: " . colored( $infile, 'bold' );
    -w $infile or throw "File is not writable: " . colored( $infile, 'bold' );

    my $pacscript = basename $infile;
    my @lines;
    {
        open my $fh, '<', $infile or throw "Could not open $infile: $!";
        chomp( @lines = <$fh> );
        close $fh or throw "Could not close $infile: $!";
    }

    info "parsing " . colored( $infile, 'underline' );

    my $pkgname = getvar 'pkgname', \@lines;
    throw 'Could not find pkgname' unless $pkgname;
    subtext "Found pkgname: " . colored( $pkgname, 'cyan' );

    my $pkgver = getvar 'pkgver', \@lines;
    throw 'Could not find pkgver' unless $pkgver;
    subtext "Found pkgver: " . colored( $pkgver, 'bright_yellow' );

    my @maintainer = getarr 'maintainer', \@lines;
    if (@maintainer) {
        subtext 'Found maintainer: '
            . colored( join( ', ', @maintainer ), 'bright_magenta' );
    } else {
        warner 'Could not find maintainer';
    }

    my $newestver;
    my $ua = LWP::UserAgent->new( show_progress => 1 );
    if ($opt_custom_version) {
        $newestver = $opt_custom_version;
    } else {
        my @repology = getarr 'repology', \@lines;
        throw 'Could not find repology' unless @repology;
        @repology = map { get_sourced $_, $infile } @repology;
        subtext 'Found repology info: '
            . colored(
            join( ', ', map { join( ':', split( ': ', $_, 2 ) ) } @repology ),
            'bright_green'
            );

        my %repology_filters = parse_repology \@repology;

        info 'Querying Repology';
        my $response = query_repology $ua, \%repology_filters;
        my $action = $opt_show_repology ? 'display' : 'newestver';
        $newestver
            = repology_get_newestver( $response, \%repology_filters, $pkgver,
            $action );
    }
    subtext colored( "Current: ", 'bold' )
        . colored( $pkgver, 'yellow' )
        . colored( " ~> ", 'blue' )
        . colored( "Latest: ", 'bold' )
        . colored( $newestver, 'green' );

    if ( version_compare_relation $pkgver, REL_GE, $newestver ) {
        info( colored( $pkgname, 'cyan' ) . " is up to date" );
        return 1;
    }
    return 1 if $opt_show_repology;

    return 1
        unless ask_yes "Proceed with updating "
        . colored( $pkgname, 'magenta' ) . " to "
        . colored( $newestver, 'green' ) . "?";
    info 'Updating pkgver';
    s/\Q$pkgver\E/$newestver/ for @lines;
    {
        open my $fh, '>', $infile or throw "Could not open $infile: $!";
        print $fh ( join "\n", @lines ) . "\n"
            or throw "Could not write to $infile: $!";
        close $fh or throw "Could not close $infile: $!";
    }

    my @arches = getarr 'arch', \@lines;
    @arches = qw(amd64) unless @arches;

    my @allSources;
    for my $arch (@arches) {
        my @sourceList;
        my @source = get_sourcearr "$arch", \@lines;
        while ( my ( $i, $entry ) = each @source ) {
            my %edict;
            $edict{'url'} = geturl $entry;
            for my $hashtype (@HASHTYPES) {
                my @sums = get_sumarr $hashtype, $arch, \@lines;
                next if grep { $_ eq 0 } @sums;
                $edict{$hashtype} = $sums[$i];
            }
            push @sourceList, \%edict;
        }

        @sourceList = grep { $_->{'url'} =~ /pkgver/ } @sourceList;
        for my $entry (@sourceList) {
            $entry->{'url'} = get_sourced $entry->{'url'}, $infile, $arch;
            subtext 'Found source ' . colored( $entry->{'url'}, 'underline' );
        }

        @sourceList = grep check_hashes, @sourceList;

        push @allSources, @sourceList;
    }
    throw 'Could not find sources' unless @allSources;

    info "Fetching sources for " . colored( $pkgname, 'bold blue' );
    $PACUP_DIR = tempdir 'pacup.XXXXXX', DIR => ( $ENV{'TMPDIR'} || '/tmp' );
    my $pkgdir = tempdir "$pkgname.XXXXXX", DIR => $PACUP_DIR;
    @lines = fetch_sources $ua, $pkgdir, \@allSources, \@lines;

    info "updating " . colored( $pacscript, 'bold yellow' );
    {
        open my $fh, '>', $infile or throw "Could not open $infile: $!";
        print $fh ( join "\n", @lines ) . "\n"
            or throw "Could not write to $infile: $!";
        close $fh or throw "Could not close $infile: $!";
    }

    if ( -x '/usr/bin/pacstall' ) {
        info "Installing from $pacscript";
        my $payload = join( ';:', @collected_files );
        local $ENV{'PACSTALL_PAYLOAD'} = $payload;
        system 'pacstall', ( '--install', $infile );
    } else {
        warner "Pacstall is not installed or not executable!";
    }

    return 1 unless $opt_ship;
    return unless ask_wait "does $pkgname work?";

    my $commit_msg = qq/upd($pkgname): \\\`$pkgver\\\` -> \\\`$newestver\\\`/;

    system 'git', ( 'add', $infile );
    my $ship_branch = "ship-$pkgname";
    my $current_branch = capture 'git',
        ( 'rev-parse', '--abbrev-ref', 'HEAD' );
    chomp $current_branch;
    if (system( 'git',
            ( 'show-ref', '--verify', '--quiet', "refs/heads/$ship_branch" ) )
        == 0
        )
    {
        return unless ask_yes "Delete existing branch $ship_branch?";
        if ( $current_branch eq $ship_branch ) {
            throw "Currently on $ship_branch";
        } else {
            system 'git', ( 'branch', '--delete', '--force', $ship_branch );
        }
    }
    system 'git', ( 'checkout', '--branch', $ship_branch );
    system 'git', ( 'commit', '--message', $commit_msg );
    my @pushargs
        = ( 'push', '--set-upstream', $opt_origin_remote, $ship_branch );
    push @pushargs, '--force-with-lease' if $opt_push_force;
    system 'git', @pushargs;

    if ( ask
        'Create PR? (must have gh installed and authenticated to GitHub)' )
    {
        system 'gh',
            ( 'pr', 'create', '--title', $commit_msg, '--body', '""' );
    }

    info "Done!";
    return 1;
}

GetOptions(
    'help|?' => \$opt_help,
    'version' => \$opt_version,
    'ship' => \$opt_ship,
    'show-repology|r' => \$opt_show_repology,
    'origin-remote=s' => \$opt_origin_remote,
    'custom-version|c=s' => \$opt_custom_version,
    'push-force' => \$opt_push_force,
) or pod2usage(2);

version_info() if $opt_version;
pod2usage(0) if $opt_help;
pod2usage(1) if !@ARGV;

check_deps();
for my $infile (@ARGV) {
    main $infile;
}

__END__

=head1 NAME

pacup - Pacscript Updater

=head1 SYNOPSIS

pacup [options]

=head1 DESCRIPTION

Pacup (Pacscript Updater) is a maintainer helper tool to help maintainers update their pacscripts. It semi-automates the tedious task of updating pacscripts, and aims to make it a fun process for the maintainer! Originally written in Python, now in Perl.

=head1 OPTIONS

=over 4

=item B<-v, --version>

Print version information and exit.

=item B<-h, -?, --help>

Print this help message and exit.

=item B<-r, --show-repology>

Print the parsed repology data and exit.

=item B<-s, --ship>

Create a new branch and push the changes to git.

=item B<-o, --origin-remote>

Specify the remote repository. Default is 'origin'.

=item B<-c, --custom-version>

Set a custom version for the package to fetch, instead of querying Repology.

=item B<-p, --push-force>

Force push to the branch, overwriting any existing one.

=back

=head1 EXAMPLE

    pacup -s packages/github-desktop-deb/github-desktop-deb.pacscript

=head1 AUTHOR

Vigress - <vig@disroot.org>

=head1 VERSION

Pacup (Perl edition) v3.0.0

=cut

# vim: set ts=4 sw=4 et:
